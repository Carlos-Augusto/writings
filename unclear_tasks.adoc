= Unclear tasks as a symptom of incomplete phases
Carlos Sanchez <carlos@recovery.cat>
v0.0.1, 2021-10
:doctype: article
:encoding: utf-8
:lang: en
:xrefstyle: short
:numbered!:

[.normal]

You can make your team more productive by introducing, maintaining, and completing specific requirements artifacts footnote:[Artifacts are seen here as a deliverable or output of a progress, it can be documents, models, or code. Requirements artifacts are not static outputs. They are more like a compass that points at your goal.] that support the communication between different levels of stakeholders and expected outputs. Efficiency is one of the main goals of any software engineering effort, and we need to realize that software engineering is composed of two different processes. One is the software development process in charge of creating software artifacts, and the other in charge of managing the execution of the project. In the software development process, there have been a lot of efforts toward offering a set of key points that help and support the translation of the requirements into software. And although, there is a clear guidance on the different phases a software development, based on its type of process, could have, I find, more and more, that the parts of the development process have become more and more informal. So informal, that requirements are sometimes transmitted only orally. If written, their description is poor, or it is composed of by a single title. This leaves a lot of room for mistake. Even if we decide to use a very light development process, we should not forget that there are parts of the development that are very crucial for a successful ending. The phase of the process where I see most of the errors is in the initial phases, in the phases of inception and elaboration <<martin_fowler>>, where we are supposed to gather requirements in a very reliable and yet flexible way. It is the gathering, prioritization and maintenance of requirements that fail. That's to say that we must take care and nurture our requirements artifacts. We should give them the level of importance they deserve as they are an element of the software development that are present throughout the whole process. We can be informal, but to what level and to what price?

The team acquires a sense of control over their tasks, which allows them to focus on doing rather than discussing. It is a general feeling, we, human beings, feel, when the destination is more or less clear, when there is a direction, when there is a goal. Efficient requirements artifacts provide control over the production of software. Having a team that is focused is very motivating in its own right. Having a highly-focused team means better products, and better internal mood of the team, which translates as a more powerful company. Being able to have a good enough, clear enough set of requirements, reduces the amount of time that the team will need to find to try and understand missing parts of the definition of the requirements, which, with time, weakens that attitude of productivity of the team. Requirements should be accessible, easy to work with, and prioritized. Requirements are a compass aiming at a goal, they are not never-updated static documents or models. And as Martin Fowler recommends <<martin_fowler>>, throw it away if you don't maintain it.

Having tasks with well-defined requirements increases the quality of the output product of the development process. Understanding what really needs to be built is very critical, especially with code. When building software products and depending on their size and complexity and maturity, building a product with certain features that be as close as possible to the ones expected is of high importance. However, building what is expected is not the only goal, building a product with a minimum amount of quality is equally important. We aim at two things, a product that matches what is expected, and a product that incorporates a quality value. When we have well-defined requirements, for example, ones that include possible risks (maybe technological risk, or political risks); and we are honoring the nature of the characteristics of the requirement artifacts - that they evolve just as much as code -, it becomes more likely that a proper tune-up or adjustment be added to the product at a proper time in its development cycle, as opposed to when possible disruptive changes are only known of and acted upon at a very late time in the software development process, which could end up in the failure of the project. Requirements artifacts are meant to be used as input to other phases of the software development, including tests. Requirements artifacts create an outline of the tests that make sense to develop and to include in the acceptance criteria. That's to say, that maintaining an alive set of requirements artifacts, we reduce the risk of failure, and we increase the expectancy and quality of the software.

The amount of time that is required at later stages for meetings is substantially reduced. When a team doesn't understand what is meant to be built or misunderstands it, it is very likely that many more meetings than those required will have to take place. Which under some circumstances, it could be very complicated or even impossible to do. It is fine to have a certain amount of ceremony for any project, especially, when it is highly risky, however, developing software is a complex task, and spending time in meetings drastically reduces the amount of time actually building the solution. Such a situation is sometimes ignored by the leaders or product owners as they find it normal or don't grasp the depths of building software. Requirements artifacts serve as indicators of the meetings that need to take place or not, at least, to the point of transferring an understanding of the solution that needs to be built.

Requirement artifacts are the underlying thread throughout the software product development. Requirements are alive, they represent our direct connection with the outer and inner world. By outer world, I mean, the stakeholders, the parties, or other actors - could be systems themselves - that expect a particular behavior from our software. By inner world, I mean, the code, the infrastructure, the components which are part of the software solution. When we look at the requirements artifacts as such entities that are the common thread in the fabric of software, we realize about their importance and recognize that they are always evolving, being verified, being expanded, being tuned up, or being discarded.

[bibliography]
== References

* [[[martin_fowler, 1]]] UML Distilled: A Brief Guide to the Standard Object Modeling Language (2nd Edition)


